{"version":3,"file":"esri-loader-hooks.cjs.production.min.js","sources":["../src/hooks/view.ts","../src/utils/arcgis.ts","../src/hooks/graphics.ts","../src/hooks/handlers.ts"],"sourcesContent":["import { useRef, useEffect, useState } from 'react';\nimport { loadView, destroyView, ILoadViewOptions } from '../utils/arcgis';\n\nexport function useWebMap(item: any, options?: ILoadViewOptions) {\n  return useView(item, options);\n}\n\nexport function useWebScene(item: any, options?: ILoadViewOptions) {\n  return useView(item, { ...options, isScene: true });\n}\n\nexport function useMap(map: any, options?: ILoadViewOptions) {\n  return useView(map, options);\n}\n\nexport function useScene(map: any, options?: ILoadViewOptions) {\n  return useView(map, { ...options, isScene: true });\n}\n\nfunction useView(map: any, options?: ILoadViewOptions) {\n  // create a ref to element to be used as the map's container\n  const elRef = useRef(null);\n  // hold on to the view in state\n  const [view, setView] = useState(null);\n  // use a ref so we can use initial values in a componentDidMount-like effect\n  // otherwise we'd get a lint error, or have to make it a dependency of the effect\n  // see: https://github.com/facebook/react/issues/15865#issuecomment-540715333\n  const initialArguments = useRef({ map, options });\n\n  // use a side effect to create the view after react has rendered the DOM\n  useEffect(() => {\n    // define local variables to be used in the clean up function\n    let cancelled = false;\n    let _view: any;\n    async function load() {\n      const { map, options } = initialArguments.current;\n      _view = await loadView(map, options);\n      if (cancelled) {\n        return;\n      }\n      // show the view at the element & add it to the state\n      _view.container = elRef.current;\n      setView(_view);\n    }\n    load();\n    return function cleanUp() {\n      // cancel any pending attempts to load the view\n      // see: https://juliangaramendy.dev/use-promise-subscription/\n      cancelled = true;\n      // clean up the map view\n      destroyView(_view);\n    };\n  }, []); // similar to componentDidMount(), componentWillUnmount()\n\n  // return the ref and the view\n  return [elRef, view];\n}\n","import { loadModules } from 'esri-loader';\n\n// is this a web map/scene?\nfunction isItem(map: any) {\n  return typeof map === 'string' || !!map.baseMap || !!map.operationalLayers;\n}\n\n// TODO: make this real\nexport interface ILoadViewOptions {\n  isScene?: boolean;\n  view?: any;\n  // [index: string]: any;\n}\n\nexport function loadView(map: any, options?: ILoadViewOptions) {\n  return isItem(map) ? loadItem(map, options) : loadMap(map, options);\n}\n\nexport function loadMap(mapProperties: any, options: ILoadViewOptions = {}) {\n  const viewModule = `esri/views/${options.isScene ? 'Scene' : 'Map'}View`;\n  return loadModules(['esri/Map', viewModule]).then(([Map, ViewClass]) => {\n    // then we create a map (or scene)\n    const map = new Map({ ...mapProperties });\n    // and return a view with that map (or scene)\n    const { view } = options;\n    return new ViewClass({\n      ...view,\n      map,\n    });\n  });\n}\n\nexport function loadItem(item: any, options: ILoadViewOptions = {}) {\n  const modules = options.isScene\n    ? ['esri/views/SceneView', 'esri/WebScene']\n    : ['esri/views/MapView', 'esri/WebMap'];\n  return loadModules(modules).then(([ViewClass, MapClass]) => {\n    // then we create a wem map (or scene) from the item\n    const map =\n      typeof item === 'string'\n        ? new MapClass({\n            portalItem: {\n              id: item,\n            },\n          })\n        : MapClass.fromJSON(item);\n    // and return a view with that web map (or scene)\n    const { view } = options;\n    return new ViewClass({\n      ...view,\n      map,\n    });\n  });\n}\n\nexport function destroyView(view: any) {\n  if (!view) {\n    return;\n  }\n  // undocumented way to destroy a view\n  view = view.container = null;\n}\n","import { useEffect } from 'react';\nimport { loadModules } from 'esri-loader';\n\nexport function useGraphics(view: any, jsonGraphics: any[]) {\n  useEffect(() => {\n    if (!view || !jsonGraphics) {\n      return;\n    }\n\n    let graphics: any[];\n    loadModules(['esri/Graphic']).then(([Graphic]) => {\n      graphics = jsonGraphics.map(jsonGraphic => new Graphic(jsonGraphic));\n      view.graphics.addMany(graphics);\n    });\n    return function removeGraphics() {\n      view && view.graphics.removeMany(graphics);\n    };\n  }, [view, jsonGraphics]);\n}\n\nexport function useGraphic(view: any, jsonGraphic: any) {\n  return useGraphics(view, [jsonGraphic]);\n}\n","import { useEffect } from 'react';\n\nexport function useEvents(\n  obj: any,\n  names: string[],\n  callback: (e: any) => void\n) {\n  useEffect(() => {\n    if (!obj) {\n      return;\n    }\n    const handles = names.map(name => obj.on(name, callback));\n    return function removeHandles() {\n      handles.forEach(handle => {\n        handle.remove();\n      });\n    };\n  }, [obj, names, callback]);\n}\n\nexport function useEvent(obj: any, name: string, callback: (e: any) => void) {\n  useEvents(obj, [name], callback);\n}\n\nexport function useWatches(obj: any, names: string[], callback: any) {\n  useEffect(() => {\n    if (!obj) {\n      return;\n    }\n    const handles = names.map(name => obj.watch(name, callback));\n    return function removeHandles() {\n      handles.forEach(handle => {\n        handle.remove();\n      });\n    };\n  }, [obj, names, callback]);\n}\n\nexport function useWatch(obj: any, name: string, callback: any) {\n  useWatches(obj, [name], callback);\n}\n"],"names":["useView","map","options","elRef","useRef","useState","view","setView","initialArguments","useEffect","_view","cancelled","current","baseMap","operationalLayers","isItem","item","loadModules","isScene","then","ViewClass","MapClass","portalItem","id","fromJSON","loadItem","mapProperties","Map","loadMap","loadView","container","load","destroyView","useGraphics","jsonGraphics","graphics","Graphic","jsonGraphic","addMany","removeMany","useEvents","obj","names","callback","handles","name","on","forEach","handle","remove","useWatches","watch"],"mappings":"mUAmBA,SAASA,EAAQC,EAAUC,OAEnBC,EAAQC,SAAO,QAEGC,WAAS,MAA1BC,OAAMC,OAIPC,EAAmBJ,SAAO,CAAEH,IAAAA,EAAKC,QAAAA,WAGvCO,aAAU,eAGJC,EADAC,GAAY,8BAGWH,EAAiBI,iCCrBvBX,EAAUC,UAXnC,SAAgBD,SACQ,iBAARA,KAAsBA,EAAIY,WAAaZ,EAAIa,kBAWlDC,CAAOd,YAiBSe,EAAWd,mBAAAA,IAAAA,EAA4B,IAIvDe,cAHSf,EAAQgB,QACpB,CAAC,uBAAwB,iBACzB,CAAC,qBAAsB,gBACCC,MAAK,gBAAEC,OAAWC,OAEtCpB,EACY,iBAATe,EACH,IAAIK,EAAS,CACXC,WAAY,CACVC,GAAIP,KAGRK,EAASG,SAASR,UAGjB,IAAII,OADMlB,EAATI,MAGNL,IAAAA,QAnCiBwB,CAASxB,EAAKC,YAGbwB,EAAoBxB,mBAAAA,IAAAA,EAA4B,IAE/De,cAAY,CAAC,0BADaf,EAAQgB,QAAU,QAAU,gBAChBC,MAAK,gBAAOC,OAEjDnB,EAAM,IAAI0B,aAASD,WAGlB,IAAIN,OADMlB,EAATI,MAGNL,IAAAA,QAZ0C2B,CAAQ3B,EAAKC,GDqBzC2B,GADN5B,MAAKC,4BACbQ,IACIC,IAIJD,EAAMoB,UAAY3B,EAAMS,QACxBL,EAAQG,0CAEVqB,GACO,WAGLpB,GAAY,WCOUL,GACrBA,IAILA,EAAOA,EAAKwB,UAAY,MDVpBE,CAAYtB,MAEb,IAGI,CAACP,EAAOG,YEpDD2B,EAAY3B,EAAW4B,GACrCzB,aAAU,eAKJ0B,KAJC7B,GAAS4B,SAKdjB,cAAY,CAAC,iBAAiBE,MAAK,gBAAEiB,OACnCD,EAAWD,EAAajC,KAAI,SAAAoC,UAAe,IAAID,EAAQC,MACvD/B,EAAK6B,SAASG,QAAQH,MAEjB,WACL7B,GAAQA,EAAK6B,SAASI,WAAWJ,MAElC,CAAC7B,EAAM4B,aCfIM,EACdC,EACAC,EACAC,GAEAlC,aAAU,cACHgC,OAGCG,EAAUF,EAAMzC,KAAI,SAAA4C,UAAQJ,EAAIK,GAAGD,EAAMF,aACxC,WACLC,EAAQG,SAAQ,SAAAC,GACdA,EAAOC,gBAGV,CAACR,EAAKC,EAAOC,IAOlB,SAAgBO,EAAWT,EAAUC,EAAiBC,GACpDlC,aAAU,cACHgC,OAGCG,EAAUF,EAAMzC,KAAI,SAAA4C,UAAQJ,EAAIU,MAAMN,EAAMF,aAC3C,WACLC,EAAQG,SAAQ,SAAAC,GACdA,EAAOC,gBAGV,CAACR,EAAKC,EAAOC,qBAflB,SAAyBF,EAAUI,EAAcF,GAC/CH,EAAUC,EAAK,CAACI,GAAOF,oDDDErC,EAAW+B,UAC7BJ,EAAY3B,EAAM,CAAC+B,mDFVLpC,EAAUC,UACxBF,EAAQC,EAAKC,8BAGGD,EAAUC,UAC1BF,EAAQC,OAAUC,GAASgB,SAAS,uBGsB7C,SAAyBuB,EAAUI,EAAcF,GAC/CO,EAAWT,EAAK,CAACI,GAAOF,oDHpCA3B,EAAWd,UAC5BF,EAAQgB,EAAMd,iCAGKc,EAAWd,UAC9BF,EAAQgB,OAAWd,GAASgB,SAAS"}