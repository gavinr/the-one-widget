import { useRef, useState, useEffect } from 'react';
import { loadModules } from 'esri-loader';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function isItem(map) {
  return typeof map === 'string' || !!map.baseMap || !!map.operationalLayers;
}

function loadView(map, options) {
  return isItem(map) ? loadItem(map, options) : loadMap(map, options);
}
function loadMap(mapProperties, options) {
  if (options === void 0) {
    options = {};
  }

  var viewModule = "esri/views/" + (options.isScene ? 'Scene' : 'Map') + "View";
  return loadModules(['esri/Map', viewModule]).then(function (_ref) {
    var Map = _ref[0],
        ViewClass = _ref[1];
    // then we create a map (or scene)
    var map = new Map(_extends({}, mapProperties)); // and return a view with that map (or scene)

    var _options = options,
        view = _options.view;
    return new ViewClass(_extends({}, view, {
      map: map
    }));
  });
}
function loadItem(item, options) {
  if (options === void 0) {
    options = {};
  }

  var modules = options.isScene ? ['esri/views/SceneView', 'esri/WebScene'] : ['esri/views/MapView', 'esri/WebMap'];
  return loadModules(modules).then(function (_ref2) {
    var ViewClass = _ref2[0],
        MapClass = _ref2[1];
    // then we create a wem map (or scene) from the item
    var map = typeof item === 'string' ? new MapClass({
      portalItem: {
        id: item
      }
    }) : MapClass.fromJSON(item); // and return a view with that web map (or scene)

    var _options2 = options,
        view = _options2.view;
    return new ViewClass(_extends({}, view, {
      map: map
    }));
  });
}
function destroyView(view) {
  if (!view) {
    return;
  } // undocumented way to destroy a view


  view = view.container = null;
}

function useWebMap(item, options) {
  return useView(item, options);
}
function useWebScene(item, options) {
  return useView(item, _extends({}, options, {
    isScene: true
  }));
}
function useMap(map, options) {
  return useView(map, options);
}
function useScene(map, options) {
  return useView(map, _extends({}, options, {
    isScene: true
  }));
}

function useView(map, options) {
  // create a ref to element to be used as the map's container
  var elRef = useRef(null); // hold on to the view in state

  var _useState = useState(null),
      view = _useState[0],
      setView = _useState[1]; // use a ref so we can use initial values in a componentDidMount-like effect
  // otherwise we'd get a lint error, or have to make it a dependency of the effect
  // see: https://github.com/facebook/react/issues/15865#issuecomment-540715333


  var initialArguments = useRef({
    map: map,
    options: options
  }); // use a side effect to create the view after react has rendered the DOM

  useEffect(function () {
    var load = function load() {
      try {
        var _initialArguments$cur = initialArguments.current,
            _map = _initialArguments$cur.map,
            _options = _initialArguments$cur.options;
        return Promise.resolve(loadView(_map, _options)).then(function (_loadView) {
          _view = _loadView;

          if (cancelled) {
            return;
          } // show the view at the element & add it to the state


          _view.container = elRef.current;
          setView(_view);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    // define local variables to be used in the clean up function
    var cancelled = false;

    var _view;

    load();
    return function cleanUp() {
      // cancel any pending attempts to load the view
      // see: https://juliangaramendy.dev/use-promise-subscription/
      cancelled = true; // clean up the map view

      destroyView(_view);
    };
  }, []); // similar to componentDidMount(), componentWillUnmount()
  // return the ref and the view

  return [elRef, view];
}

function useGraphics(view, jsonGraphics) {
  useEffect(function () {
    if (!view || !jsonGraphics) {
      return;
    }

    var graphics;
    loadModules(['esri/Graphic']).then(function (_ref) {
      var Graphic = _ref[0];
      graphics = jsonGraphics.map(function (jsonGraphic) {
        return new Graphic(jsonGraphic);
      });
      view.graphics.addMany(graphics);
    });
    return function removeGraphics() {
      view && view.graphics.removeMany(graphics);
    };
  }, [view, jsonGraphics]);
}
function useGraphic(view, jsonGraphic) {
  return useGraphics(view, [jsonGraphic]);
}

function useEvents(obj, names, callback) {
  useEffect(function () {
    if (!obj) {
      return;
    }

    var handles = names.map(function (name) {
      return obj.on(name, callback);
    });
    return function removeHandles() {
      handles.forEach(function (handle) {
        handle.remove();
      });
    };
  }, [obj, names, callback]);
}
function useEvent(obj, name, callback) {
  useEvents(obj, [name], callback);
}
function useWatches(obj, names, callback) {
  useEffect(function () {
    if (!obj) {
      return;
    }

    var handles = names.map(function (name) {
      return obj.watch(name, callback);
    });
    return function removeHandles() {
      handles.forEach(function (handle) {
        handle.remove();
      });
    };
  }, [obj, names, callback]);
}
function useWatch(obj, name, callback) {
  useWatches(obj, [name], callback);
}

export { useEvent, useEvents, useGraphic, useGraphics, useMap, useScene, useWatch, useWatches, useWebMap, useWebScene };
//# sourceMappingURL=esri-loader-hooks.esm.js.map
